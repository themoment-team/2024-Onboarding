## JAVA
### 클래스, 객체, 인스턴스의 개념 및 차이점

![image](/2024-Onboarding/kimjihoon3106/java/image/image-2.png)

#### 클래스 (class)

* 객체를 만들기 위한 설계도 또는 틀이다.
* 객체가 가져야 하는 속성(attribute)과 행동(method)을 정의한다.
* Ex) '사람'클래스는 이름, 나이, 성별과 같은 속성을 가지며, '먹다', '잠자다'와 같은 행동을 할 수 있도록 정의될 수 있다.
* 클래스는 객체를 생성하기 위한 틀이지만, 실제 데이터를 가지지 않는다.

#### 객체 (Object)
* 객체는 클래스로부터 생성된 실제 데이터이다.
* 클래스에 정의된 속성과 행동을 가지며, 실제 프로그램에서 사용될 수 있다.
* Ex) '사람'클래스의 객체는 실제 사람인 '철수', '영희'등이 될 수 있다.
* 객체는 실제로 메모리에 할당되어 사용된다.
#### 인스턴스 (instance)
* 인스턴스는 클래스로부터 생성된 특정한 객체를 의미한다.
* '클래스의 인스턴스'라고도 한다.
* 클래스로부터 생성된 객체가 인스턴스이다.
* Ex) '사람'클래스로부터 생성된 '철수'객체는 '사람'클래스의 인스턴스이다.
<br>
<br>

📌 **즉, 클래스는 객체를 만들기 위한 설계도이고, 객체는 클래스로부터 생성된 실제 데이터이며, 인스턴스는 클래스로부터 생성된 특정한 객체를 가리킨다.**

Ex)
```bash
// 클래스
public class People {
	...
}

// 객체와 인스턴스
public class Main {
	public static void main(String[] args) {
    	People person1, person2;
        
        // 인스턴스화
        person1 = new People(); 
        // person1은 People 클래스의 '인스턴스'
        (객체를 메모리에 할당)

        person2 = new People(); 
        // person2은 People 클래스의 '인스턴스'
        (객체를 메모리에 할당)
    }
}
```

#### 클래스, 객체, 인스턴스의 차이

#### 클래스(Class)와 객체(Object)의 차이
* 클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상'을 의미한다.
#### 객체(Object)와 인스턴스(Instance)의 차이
* 클래스의 특정 객체라는 개념을 강조할 때 주로 사용된다.
* 인스턴스는 객체와 클래스와의 관계를 강조한다.
* 객체는 메모리에 할당된 데이터를 의미한다.

### 추상 클래스와 인터페이스의 개념 및 차이

#### 추상 클래스 (Abstract Class)
* 주로 클래스들의 공통되는 필드와 메서드를 정의한 클래스이다.
* 추상 메소드를 선언하여 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스이다.
* 인스턴스를 직접 생성할 수 없고, 하위 클래스에 의해 확장 및 구현되어야 한다.
* 추상클래스는 메서드의 선언만 있고 구현이 없는 추상 메서드를 포함할 수 있다.
* 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수 없다.

#### 추상 클래스의 특징
* 추상 클래스는 클래스 앞에 abstract 키워드를 이용해서 정의한다.
* 추상클래스는 미완성의 추상 메서드를 포함할 수 있다.
* 추상 메소드란, 내용이 없는 메서드이다. 즉, 구현이 되지 않은 메서드이다.
* 추상 클래스는 인스턴스를 생성할 수 없다, 자체적으로 객체를 생성할 수 없다.
* 따라서, 상속을 통해 자식 클래스에서 인스턴스를 생성해야 한다.

Ex)
```bash
public abstract class (클래스명) {
	public abstract void (메서드명)
}
```
---
<br>
<br>
* 추상 클래스를 상속받은 클래스는 추상 클래스가 갖고 있는 추상 메서드를 반드시 구현(Overriding) 해야 한다.<br>
* 추상 클래스를 상속받고, 추상 클래스가 갖고 있는 추상 메서드를 구현하지 않으면 해당 클래스도 추상 클래스가 된다.<br>
Ex)

```bash
Public class (클래스명) extends (추상클래스명) {
	@Override
    public void (메서드명)() {
    	---
    }
}
```
---
<br>
<br>
* 추상 클래스는 객체를 생성할 수 없다.<br>
Ex)

```bash
public class (추상 클래스명) { 
    public static void main(String[] args) {
        (추상 클래스를 상속받은 클래스) (추상 클래스를 상속받은 클래스) = new (추상 클래스를 상속받은 클래스)();
        (추상 클래스를 상속받은 클래스).(메서드명)();
        (추상 클래스를 상속받은 클래스).(메서드명)();
        
        // 추상 클래스는 인스턴스화 시킬 수 없다.
        //(추상 클래스명) (추상 클래스명) = new (추상클래스명)();
    }   
}
```
---

#### 추상 클래스 사용 이유

1. 공통 필드와 메소드 통일 목적
>   * 공통적으로 작성되어야 하는 내용들이 생길 때 서로 다른 메서드 명이나 필드 명을 사용하게 된다면 유지보수 및 관리 등 문제가 발생하게 된다.
>   * 따라서 추상클래스를 사용함으로써 공통된 내용들을 추출하여 통일된 내용으로 작성하도록 규격화하는 것이다.
>   * 상속받은 클래스들은 자기 클래스의 필요한 메서드나 필드만 추가로 정의하고, 추상 메서드를 오버라이딩하여 클래스마다 다르게 실행될 로직을 작성해 주면 된다.
>   * 따라서, 필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다.

2. 실체 클래스 구현시, 시간절약
>   * 실제 프로젝트에서 AA(Application Architecture)가 설계해 놓은. 추상 클래스를 상속받으면, 프로젝트에서 공통적으로 들어가야 하는 필드와 메서드가 오버라이딩 된다
>   * 강제로 주어지는 필드와 메서드를 가지고 자신만의 스타일대로 구현하면 된다
>   * 설계시간이 절약되고, 구현에만 집중할 수 있다.
3. 객체지향적인 설계
>   * 소스 수정시 다른 소스의 영향도를 적게 가져가면서 변화에는 유연하게 만들기 위해 추상클래스를 사용하기도 한다.
>   * 추상클래스를 상속받아서 미리 정의된 공통 기능들을 구현하고, 실체클래스에서 필요한 기능들을 클래스별로 확장시킬 수 있다.
>   * 추상 클래스를 상속받은 실체 클래스들은 반드시 추상메서드를 재정의(Overriding)해서 실행 내용을 작성해야 한다.
>   * 코드 수정 시, 영향도를 적게 가져가면서 유지보수성을 높일 수 있다.
>   * 규격에 맞게 소스가 구현되어 있기 때문에 해당 규격에 대한 구현부만 수정하면 손쉽게 기능 수정이 가능하기 때문이다.

---
#### 인터페이스 (interface)
* interface 키워드를 사용하여 선언하는 인터페이스 상수(static final)와 추상 메서드(abstract method)의 집합이다.
* 클래스와 다르게 다중상속 구현이 가능하다.
* 인터페이스는 추상 클래스보다 추상화 정도가 높으며 추상 클래스와는 다르게 구현부가 있는 일반 메서드, 일반 멤버 변수를 가질 수 없다는 특징이 있다.
* 인터페이스의 모든 메서드는 'public abstract'로 선언해야 하며, 이를 생략할 수 있다. 또한 모든 멤버 변수는 'public static final'으로 선언해야 하며, 마찬가지로 이를 생략할 수 있다(생략할 수 있는 이유는 컴파일 시 자동으로 생성해 주기 때문이다.)<br>
<br>
Ex)

```bash
interface (인터페이스명) {
	...

    public static (상수이름) = (값);
    
    public abstract void 메서드이름();
    
    public default void 메서드이름(){};
}
```

---

#### 추상 클래스와 인터페이스의 차이점

![image](/2024-Onboarding/kimjihoon3106/java/image/image-1.png)

* 추상 클래스는 extends(상속, 확장의 느낌) 키워드 그대로 자신의 기능들을 하위로 확장시키는 것으로 볼 수 있다.
* 인터페이스는 implements(상속, 구현의 느낌) 키워드처럼 인터페이스에 정의된 메서드를 각 클래스의 목적에 맞게 동일한 기능으로 구현하는 것으로 볼 수 있다.
* 추상 클래스는 이를 상속할 각 객체들의 공통점을 찾아 추상화시켜 놓은 것으로 상속 관계를 타고 올라갔을 때, 같은 부모 클래스를 상속하며, 부모 클래스가 가진 기능들을 구현해야 하는 경우에 사용한다.
* 반면 인터페이스는 상속 관계를 타고 올라갔을 때, 다른 부모 클래스를 상속하더라도 같은 기능이 필요한 경우에 사용된다.
<br>
<br>
<br>
<br>

* 즉, 자바의 특성상 한 개의 클래스만 상속이 가능하기 때문에 해당 클래스의 구분을 추상 클래스 상속을 통해서 해결하고, 할 수 있는 공통된 기능들을 인터페이스의 다중 상속을 통해 구현한다.
* 상위 클래스는 다중 상속이 불가능하기 때문에 하나의 클래스에서 하위 클래스에 물려줄 특성이 풍부할수록 좋고, 인터페이스는 다중 상속이 가능하기 때문에 각각의 인터페이스는 목적에 맞는 최소한의 메서드(구현을 강제할)를 선언하는 것이 좋다

---
### 오버라이딩 (overriding), 오버로딩 (overloading)

#### 오버라이딩 (overriding)
* 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의 하는것.
* 상속받은 메소드를 그대로 사용할 수도 있지만. 자식 클래스에서 상황에 맞게 변경해야하는 겅우 오버라이딩할 필요가 생긴다.

#### 오버라이딩의 조건
* 부모 클래스의 메소드를 재정의하는 것으로 메소드의 이름이 일치해야 함
* 메소드 매개변수의 갯수, 순서 그리고 데이터 타입이 일치해야 한다
* 메소드의 return 타입이 일치해야 한다.

#### @Override는 어떤 용도인가?
* 검증하는 기능을 한다
* 오버라이딩을 검증하는 기능을 한다.
* 부모 클래스의 메소드를 오버라이딩하는 것은 내용만을 새로 정의하는 것이므로 선언부는 부모의 것과 완벽히 동일해야 한다.
* 부모의 메소드의 이름만 빌려와서 자기의 방식대로 재정의하는것을 오버라이딩이라고 한다.
* 오버라이딩에서 접근 제어자를 설정하는 규칙이 존재한다.
>   1. 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설장할 수 없다.
>   2. 예외(Exception)는 부모 클래스의 메소드 보다 많이 선언할 수 없다.
>   3. static메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.

---

#### 오버로딩 (overloading)
* 같은 클래스 내부에서 메소드를 확장하기 위한 개념이다.
* 하나의 함수가 하나의 기능만을 구현해야 한다는 것이다.
* 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.
#### 오버로딩의 조건
* 메소드의 이름이 일치해야 한다.
* 메소드 매개변수의 개수 또는 타입이 달라야 한다 (개수가 같다면 타입, 타입이 같다면 개수를 다르게 해야한다)
* 메소드의 return 타입이 달라야 한다.

#### 오버로딩을 사용하는 이유
1. 같은 기능을 하는 메소드를 하나의 이름을 사용할 수 있다.
>   * 같은 기능을 가진 메소드를 하나의 이름으로 정으가 가능한 것이다.
2. 메소드의 이름을 절약할 수 있다.
>   * 매개변수의 종류에 따라서 다르게 이름을 지정한다고 하면 수많은 메소드들의 이름을 정해줘야 할것이다.
>   * 이는 프로그래머의 입장에서 메소드의 네이밍에 고민을 가중시킨다 또한, 이런 이름들은 다른 곳에 사용해야 될 수도 있기 때문이다.

---
#### 다형성 (polymorphism)

* 객체지향 프로그래밍의 핵심 개념 중 하나이다.
* 하나의 객체가 여러가지 타입을 가질 수 있는 것이다.
* 오버라이딩은 다른 메소드 시그니처를 통해 여러가지 자료형을 인수로 받을 수 있다.
* 오버라이딩은 상속 관계의 객체 간의 메소드를 재정의 함으로써 동일한 시그니처를 가진 메소드를 자료형에 적합하게 사용할 수 있다.

#### 오버라이딩
* 상속 또는 구현 관계에서의 메소드를 재정의하는 기법을 의미한다.
* 상속을 통해 하위 객체를 상위 객체의 자료형으로 다룰 수 있다.
* 같은 메서드 이지만 객체에 따라 다르게 작동한다.
* 즉, 다형성을 이미 적용받고 있으며, 오버라이딩된 메소드를 사용함으로써 다형성을 더욱 강화할 수 있다.

---

#### 오버로딩과 오버라이딩의 차이점

#### 오버로딩
* 기존에 없는 새로운 메소드를 추가하는 것
#### 오버라이딩
* 상속받은 메소드를 재정의 하는 것

##### 접근제어자
>   * 오버로딩 : 모든 접근 제어자를 사용할 수 있다.
>   * 오버라이딩 : 부모 클래스의 메소드의 접근 제어자보다 더 넓은 범위의 접근 제어자를 자식 클래스의 메소드에서 설정할 수 있다.
##### 리턴형
>   * 오버로딩 : 달라도 된다.
>   * 오버라이딩 : 동일해야 한다.
##### 메소드명
>   * 오버로딩 : 동일해야 한다.
>   * 오버라이딩 : 동일해야 한다.
##### 매개변수
>   * 오버로딩 : 달라야만 한다.
>   * 오버라이딩 : 동일해야 한다.
##### 적용범위
>   * 오버로딩 : **같은 클래스** 내에서 적용된다.
>   * 오버라이딩 : **상속관계**에서 적용 된다.