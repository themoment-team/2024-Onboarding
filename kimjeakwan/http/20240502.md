# http
- 텍스트 기반의 통신 규약으로 인터넷에서 데이터를 주고받을 수 있는 프로토콜이다.(프로토콜은 통신 규약 및 약속)
# http 의 특징
1. 클라이언트-서버 구조

- 클라이언트가 서버에 요청을 보내면, 서버가 요청에 대한 응답을 보내는 구조인 클라이언트-서버 구조로 이루어 진다.
- 클라이언트:클라이언트는 서버의 서비스를 받아 사용하는 장치, 프로그램을 말한다(예: 웹 브라우저 )
서버: 서버는 네트워크를 통해 클라이언트에게 서비스를 제공하는 시스템이다.
![alt text](image-1.png)

2. 무상태 프로토콜(stateless)
- HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는 것 이기 떄문에  응답과 요청이 독립적이다.
- 클라이언트의 상태는 웹 애플리케이셔의  관리되는 데이터를 의미 한다.
- 예로 클라이언트가 이전 정보를 저장 하지 않기 떄문에  전에 요청까지 한번 에 다시 요청해야 한다.
- 하지만 쿠키나 세션 등등을 활용하여  여러 요청과응답의 진행과정이나 데이터 를 쓸수있다.
3. 비열결성(connectionless)
- 요청이 있을떄만 연결을 유지하고 이후 응답으로 데이터를 보낸 후 연결을 종료 하는 것 이다.
- 데이터 전송이 필요할 떄 만 연결을 하기 떄문에 동시에 처리 하는 요청이 줄어든다.
- 큰 규모의 서비스를 운영할 떄 비연결성은 한계를 보인다.
![alt text](image.png)
- TCP/IP 연결을 새로 맺어야하므로 3 way handshake 시간이 추가된다. 
-  웹 브라우저로 사이트를 요청하면 수 많은 자원이 같이 다운로드되는데 비연결성은 보낼떄마다 끊고 다운로드 하면 당연히 비효율적 일 수밖에 없다.
![alt text](image-2.png)


-  지속 연결에서는 연결이 이루어지고 난 뒤 각각의 자원들을 요청하고, 모든 자원에 대한 응답이 돌아온 후에 연결을 종료한다. http 1.1 에서 지속 연결이 가능해지면서 이런 문제가 해결이 되었다.
![alt text](image-3.png)
4. http 1.1 지속연결
- 지속연결은 서버가 클라이언트의 요청의 대해서 응답한 후 TCP연결을 유지하는 방식으로 같은 클라이언트-서버간의 요청-응답이 동일한 TCP연결을 통해 이루어지는 연결 방식 이다. 그리고 어느 한쪽이 명시적으로 연결을 종료하지 않으면 TCP 연결을 유지한다.
- TCP 연결을 비연결성 처럼 연결과 종료를 반복되는 오버헤드를 줄여주어서  부담이 줄어든다.
- 한개의 TCP연결은 하나의 요청메시지와 하나의 응답메시지만 전송가능 하기 떄문에 서버의 동시접속자가 10만명이라면 서버는 10만개의 쓰레드가 필효하다.
- 쓰레드는 각 클라이언트의 요청마다 요청을 처리하는 프로세스를 두는 것 이다.
5. 비지속 과 지속연결의 차이점
비지속연결은 요청이 있을떄만 연결을 하고 응답으로 데이터를 보낸후 연결을 끊고 지속열결은 응답으로 데이터를 보낸후 에도 연결을 지속한다.

  
# http 메서드
1. GET
- 리소스를 조회하는 메서드 이다.(리소스:사용할 수 있는 어떤 것 )
- 멱등성 이라는 개념을 지니고 있어, 여러 번 조회 요청을 하여도 리소는 변하지 않는다.
- 쿼리스트리을 통해서 전달한다.(쿼리스트링은 URL의 뒤에 입력 데이터를 함께 제공하는 가장 단순한 데이터 전달 방법이다 )
2. POST
- 주로 새로운 리소스를 생성 하는데 사용한다.
- 데이터를 메세지 바디에 쿼리 파라미터 형식으로 전달 한다.(쿼리 파라미터는 key-value 형식으로 되어 있다.)
![alt text](image-4.png)
- 데이터가 외부로 노출되지 않으므로 보안성이 좋다.
- Body에 담아 전송하므로, 메세지 길이의 제한이 없다.
3. put: 리소스를 완전히 대체한다.
- 예를 들어 A,B 라는 데이터가 존재하는데 C라는 데이터를 담아 put 요청을 보낸다면 A,B 데이터가 삭제되고 C 데이터로 대체한다.
4. PATCH
- 리소스를 부분 변경한다.
- 예를 들어 A,B 라는 데이터가 있는데 B=C 로 PATCH 요청을 보내면 B는 삭제하고 A,C  데이터 가 남는다. 
5. DELETE 
- 리소스를 제거하는 역할이다.

# TCP/IP 란
1. 팻킷
- 패킷은 데이터를 나누는 작은 다위로 전송되기 전에 피캣으로 쪼개어지고 각 패킷에 고유번호 붙는다. 이후 최종 수신지에 도착했을때 번호 순서대로 결합 하는 것이다.
2. TCP/IP
- TCP 프로토콜은 신뢰성 있고 무결성을 보장하는 연결을 통해 데이터를 안전하게 전달해주는 전송 프로토콜이다 그리고 TCP는 패킷을 추적 관리 한다.
- IP는 컴퓨터의 주소이며, 192.168.9.255와 같이 3개의 마침표로 나뉘어진 숫자로 표시되며 데이터를 전달 해준는 역할
- SOCKET 는 데이터를 내보내거나 혹은 데이터를 받는 역할을 한다.
- 3 way-handshake 는 TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정 하는 과정
-
# 웹 브라우저 요청 흐름 
1. 웹 브라우저에 URL 입력
2. IP는 DNS를 조회해서 얻고, PORT정보로 HTTP 요청 메세지를 생성한다.
![alt text](image-5.png)
3. socket 라이브러리를 통해 
헤더 부분에 IP,PORT 정보를 넣어 3 way-handshake로 클라이언트와 서버를 연결한다. 그 후 연결이 성공하면 http의 메세지를 TCP/IP 계층에 전달
4. 해더 부분에 출발지 IP,port,목적지 Ip,port 정보를 담고 데이터 부분에서 http 요청 메세지를 담아 tcp/ip  패킷을 생성한다. 
5. Tcp/ip 패킷이 클라이언트에서  웹 서버에 패킷을 전달한다.
6. 서버에 도착한 헤더 부분은 버리고 http 요청 메세지를 서버가 해석하여 http응답 메세지를 만든다.
![alt text](image-6.png)
7. 응답 패킷을 클라이언트에 전달한다. 응답 패킷이 클라이언트이 도착 하면 응답 패킷에 헤더 부분을 버리고 http  응답 메세지의 데이터를 화면에 보여준다.
#  http 의 상태구조
1. http의 상태 코드는 클라이언트가 보낸 HTTP 요청이 성공했는지 실패했는지를 서버에서 알려주는 숫자 코드다.

1. 1xx
- 1xx 번대의 상태 코드들은 요청이 수신되어 처리 중이라는 의미를 가진다.
- 예 로는 102(processing) 으로 서버가 요청을 아직 처리중이라 제대로된 응답을 알려줄수 없다
2. 2xx
- 번대의 상태 코드들은 요청이 정상적으로 처리되었다는 의미를 가진다.
- 예를 들어 200 은 요청이 성공적으로 수행되었음을 의미한다. (주로 GET 요청에 대한 응답이다)
3. 3xx
- 3xx 번대의 상태 코드들은 리다이렉션을 의미하며  이는 클라이언트의 요청을 완료하려면 추가적인 작업(페이지 이동)이 필요함을 의미한다.

- 리다이렉션 은 클라이언트가 요청한 URL에 대해 다시 지시하여 주소로 이동할 수 있게 하는 기술이다.
-  영구 리다이렉션:특정 리소스의 URL 이 영구적으로 이동
-  일시 리다이렉션:특정 리소스의 URL 이 영구적으로 이동
-  특수 리다이렉션: 캐시를 활용할 것이지에 대한 여부
- 캐시는 자주 사용되는 데이터를 임시로 복사해두는 임의의 장소
4. 4xx
- 잘못된 문법 등의 오류로 인해 서버가 요청을 수행할 수 없고 그 원인 이  클라이언트에게 있음을 뜻한다. 잘못 한 구성된 요청 메세지, 존재하지 않은 URL 요청도 있을 수 있다.
5. 5xx
- 5xx 의 상태코들은 서버 오류를 의마하고 4xx는 클라이언트에게 원이 있는거고 5xx 는 서버에게 원이 이 있는 것이다.
# http 2.0 의 기능 
1. http 2.0
- SPDY 는 http 2.0 원조 이고 웹페이지의 로드 지연 시간을 줄이는 것을 목표로 잡은 프로토콜 이다.
2. Frame, stream, messages
- stream 은 Connection 내에서 Client 와 Server 간의 데이터 전달 흐름을 의미한다.
- Message는 요청 혹은 응답의 단위이며 다수의 Frame으로 이루어진 배열 라인
- Frame:http에서 통신의 최소 단위이며, header 혹은 data가 들어있다.
- HTTP/2 는 HTTP 요청을 여러개의 Frame들로 나누고 이 frame들이 모여 요청/응답 Message가 되고 그리고 Message는 특정 Stream에 속하게 되고 여러개의 Stream은 하나의 Connection에 속하게 되는 구조이다. 하나의 커넥션에 여려개의 스트림이 동시에 열리니 속도가 빨라진다.
3. Multiplexing 
- 앞 처럼 하나의 커넥션으로 동시에 여러개의 메세지 스트림을 응답 순서에 상관없이 주고 받는 것을 멀티플렉싱 이다.
- HTTP 2에서는 하나의 커넥션에 여러 개의 스트림이 동시에 요청/응답 한다.

4. Server Push
- 클라이언트의 요청에 대해 필요할것 같은 리소스들을 미리 보내는 것이다.
- 서버는 요청하지도 않은 리소스를 미리 보내어 가까운 미래에 특정 개체가 필요할때 바로 사용 할수 있도록 하는 것

5. Stream Prioritization
- http 1.1 의 HOLB는 pipelining을 통해 동시 요청을 통애 시간을 감소 시켰지만 만약 첫 번쨰 요청에 대한 응답이 길어질 경우 그 뒤에 요청도 오래걸리기 떄문에 총 시간이 더 길어졌다.
- 하지만 http2.0 에서는 리소스간 우선순위를 설정하여 이런 문제를 해결했다.
3. Header data Compression
- http 2.0은 http 메세지의 헤더를 압축하여 전송한다.또 http1.1 에서는 연속적으로 http메세지들에게서 헤더값이 중복되는 부분이 많아 메모리 낭비가 되었는데 http 2.0 은 헤더의 중복된 내용을 재전송하지 않도록하여 데이터를 절약할수 있다.













